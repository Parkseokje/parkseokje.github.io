{"meta":{"title":"석제의 블로그","subtitle":"우주의 힘으로 개발하자","description":null,"author":"Seokje Park","url":"http://parkseokje.github.io"},"pages":[],"posts":[{"title":"Namespace","slug":"namespace","date":"2017-03-10T03:33:34.000Z","updated":"2017-03-10T06:52:32.000Z","comments":true,"path":"2017/03/10/namespace/","link":"","permalink":"http://parkseokje.github.io/2017/03/10/namespace/","excerpt":"","text":"이번에 다루게 될 주제는 네임스페이스(Namespace) 이다.한가지 예를 들어 보자. helloworld1.js1var a = 'Hello World'; helloworld2.js1var a = 'HelloWorld'; index.html12345&lt;script src=\"helloworld1.js\"&gt;&lt;/script&gt;&lt;script src=\"helloworld2.js\"&gt;&lt;/script&gt;&lt;script&gt; console.log(a); // output: 'HelloWorld'&lt;/script&gt; 위 경우 index.html 파일에는 helloworld1.js 와 helloworld2.js가 동시에 공존하게 된다.12var a = 'Hello World';var a = 'HelloWorld'; 따라서 console.log(a); 의 값은 helloworld2.js 의 a 값인 HelloWorld 가 출력된다. 이유는 양쪽의 a 가 전역변수로 선언되었기 때문이다.네임스페이스는 이런 전역(Global, Window)변수의 선언으로 발생하는 문제를 피하기 위한 자바스크립트 코딩 기법이다.또는 일련의 변수와 함수 및 객체들의 컨테이너로서 다른 라이브러리과 한곳에 공존할 수 있도록 하는 방법이다. 네임스페이스를 구현하는 패턴에는 여러가지가 있다.이들 중 한가지는 Single global variable pattern (단일 전역변수 패턴) 이 있다.구현하는 방법은 즉시 실행함수(IIFE, Immediately-invoked function expression)를 사용하는 것이다. 1234567891011var greet = (function() &#123; var message = 'Hello '; var say = function() &#123; return message + 'World!'; &#125;; return &#123; say: say &#125;&#125;)();greet.say(); // output: Hello World 위 코드의 경우 return {..} 을 통해서 say 함수만 노출하고 있다.따라서 아래와 같이 message 를 호출할 경우 undefined 가 출력된다. 1greet.message; // output: undefined 주의할 점은, 단일 전역변수를(여기서는 greet) 다른 누군가에 사용되지 않을만한 이름을 가져야 한다는 것이다. 다른 패턴은 객체 리터럴 방식(Object Literal Notation)을 사용하는 것이다. 12345678var greet = greet || &#123;&#125;;greet.message: 'Hello ';greet.say: function() &#123; return this.message + 'World!';&#125;;greet.message; // output: Hellogreet.say(); // output: Hello World 여기서 눈여겨 볼 사항은 아래 코드이다.1var greet = greet || &#123;&#125;; 기본값을 지정하는 방법으로 이전 포스트에서 소개한 적이 있는 || (OR 연산자)를 사용하고 있다.이것은 단일변수패턴이 가지고 있는 전역변수의 중복문제를 피할 수 있는 방법이다. 다른 방법으로는, 아래를 참고하자.12345Option 1: var myApplication = myApplication || &#123;&#125;; // 제일 많이 사용함Option 2 if(!MyApplication) MyApplication = &#123;&#125;;Option 3: var myApplication = myApplication = myApplication || &#123;&#125;Option 4: myApplication || (myApplication = &#123;&#125;);Option 5: var myApplication = myApplication === undefined ? &#123;&#125; : 즉시 실행형 함수(IIFE) 를 사용했을때 전역변수의 중복문제를 피하려면 아래와 같이 사용한다.123456789var namespace = namespace || &#123;&#125;;(function( namespace )&#123; namespace.foo = \"foo\"; namespace.bar = function() &#123; return \"bar\"; &#125;;&#125;)(namespace);console.log(namespace.foo); // output: \"foo\" 위와 같지만 전역변수를 제거한 방식. 123456789101112;(function(namespace, undefined) &#123; namespace.foo = \"foo\"; namespace.bar = function()&#123; return \"bar\"; &#125;; // private method (외부에서 접근할 수 없다.) function speak(msg) &#123; console.log(\"You said: \" + msg); &#125;;&#125;)(window.namespace = window.namespace || &#123;&#125;);console.log(namespace.foo); // output: \"foo\" ;(function( o, undefined ) 을 보면, undefined 가 있다.ES5 이전에는 undefined 변수가 수정될 수 있었다고 한다. 그래서 본연의 undefined 을 네임스페이스 내에서 사용하기 위해 위와 같이 사용한다.세미콜론(;) 을 함수 앞에 추가하는 이유는, 즉시 실행형 함수로 구현된 다른 파일들이 한 파일로 합쳐졌을 때 충돌을 피하기 위함이다. 네임스페이스를 확장하고 싶다면 아래와 같이 추가만 하면 된다. 123456;(function(namespace, undefined) &#123; // public method (외부에서 접근할 수 있다.) namespace.sayGoodbye = function() &#123; speak('goodbye'); &#125;&#125;)(window.namespace = window.namespace || &#123;&#125;); 참고 우너효 @ NHN NEXT JDM’s Blog Essential JavaScript Namespacing Patterns","categories":[{"name":"개발","slug":"개발","permalink":"http://parkseokje.github.io/categories/개발/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://parkseokje.github.io/tags/javascript/"},{"name":"udemy","slug":"udemy","permalink":"http://parkseokje.github.io/tags/udemy/"}]},{"title":"Object and Function","slug":"objectAndFunction","date":"2017-03-09T15:12:33.000Z","updated":"2017-03-10T03:33:20.000Z","comments":true,"path":"2017/03/10/objectAndFunction/","link":"","permalink":"http://parkseokje.github.io/2017/03/10/objectAndFunction/","excerpt":"","text":"오늘은 Object 와 Fuction 에 대해 알아보자. 우선, Object 에 대해 정의해보자.12345Objects are collections of name value pairs.객체는 이름과 값의 집합이다.And those values can be other collections of name value pairs.그리고 그 객체의 값들은 또 다른 이름과 값의 집합이 될 수 있다. 그렇다면, 위에서 예기하는 값이란 무엇일까?123Primitive &quot;property&quot;Object &quot;property&quot;Fuctnion &quot;method&quot; 객체의 값이 Primitive 타입일 경우 속성(property)이라고 하며, String, Boolean, Number 등과 같은 기본 타입을 일컫는다. 이에 대한 자세한 설명은 이곳을 참고하길 바란다.객체의 값이 자신과 같은 Object 타입일 경우에 역시 속성이라고 하며, 객체의 값들은 또 다른 이름과 값의 집합 이라는 위의 설명과 같다.근데, Function (함수) 는 메소드(method, 객체 안에 정의되어 있을 경우) 라고 한다. Primitive, Object, Function 은 메모리상에 각각의 주소들을 가지고 있으며, 이를 감싸고 있는 객체는 이들의 메모리 주소를 참조하고 있다. 그럼 객체를 생성하는 방법을 알아보자. 두 가지다.12var person = new Object();var person = &#123;&#125;; // 객체 리터럴(Object Literals) var person = {};을 객체 리터럴(Object Literals) 형식이라고 한다. 객체의 속성을 정의하는 방법도 두 가지다.12person[\"name\"] = \"Tony\";person.name = \"Tony\"; person[&quot;firstname&quot;] 의 경우 Computed Member Access 타입이라고 하며, brakets ([..]) 연산자가 사용된다.person.firstname의 경우 Member Access 타입이라고 하며, curly braces ({..}) 연산자가 사용된다.둘의 차이점이라면 첫 번째의 경우 아래와 같이 &quot;firstname&quot; 대신 변수(firstNameProperty)를 할당할 수 있다는 점이다. 123person[\"firstname\"] = \"Tony\";var firstNameProperty = \"firstname\";console.log(person[firstNameProperty]); // output: \"Tony\" 위에서 객체(Object)는 객체를 속성(Property) 으로 둘 수 있다고 했다.아래 코드를 함께 보자. 12345678910111213141516person.address = new Object();person.address.street = \"시루봉로\" // person[\"address\"][\"street\"] 와 동일person.address.dong = \"방학동\"person.address.gu = \"도봉구\"person.address.si = \"서울시\"또는 객체 리터럴(Object Literals) 형태로 작성할 수 있다.person.address = &#123;&#125;;person.address: &#123; street: \"시루봉로\", dong: \"방학동\", gu: \"도봉구\", si: \"서울시\" &#125;&#125; 와 같이 표현할 수 있다. 가급적 두번 째(객체 리터럴 형식) 방식을 권장한다. 권장하는 이유는 가독성이 좋고 직관적으로 이해가 더 쉽기 때문이다.객체는 객체를 속성으로 가질 수 있다고 했다. 객체 리터럴 표기법에서는 {..} 의 중첩으로 표현한다. person 객체의 전체적인 모양은 아래와 같다.1234567891011person: &#123; firstname: \"Seokje\", lastname: \"Park\", address: &#123; street: \"시루봉로\", dong: \"방학동\", gu: \"도봉구\", si: \"서울시\" &#125; &#125;&#125; 뭐 이런 것도 가능하다. 123456function greet(person) &#123; console.log('Hi, ' + person.firstname);&#125;// output: Hi, Seokjegreet(&#123; firstname: 'Seokje', lastname: 'Park' &#125;); 다음 시간에는 Function 에 대해 알아보자.","categories":[{"name":"개발","slug":"개발","permalink":"http://parkseokje.github.io/categories/개발/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://parkseokje.github.io/tags/javascript/"},{"name":"udemy","slug":"udemy","permalink":"http://parkseokje.github.io/tags/udemy/"}]},{"title":"Boolean and Existence, Default Values","slug":"TheWeirdPartOfJavascript-1","date":"2017-03-08T16:43:03.000Z","updated":"2017-03-10T03:04:51.000Z","comments":true,"path":"2017/03/09/TheWeirdPartOfJavascript-1/","link":"","permalink":"http://parkseokje.github.io/2017/03/09/TheWeirdPartOfJavascript-1/","excerpt":"","text":"오늘부터 Udemy 에서 수강한 내용을 요약해보려 한다.오늘은 JavaScript: Understanding the Weird parts 의Boolean and Existence 그리고 Default Values 에 대한 내용이다. 1234var a; // undefinedif (a) &#123; console.log('hello');&#125; 위 코드에서 if(a) 를 통해 a의 형변환(coerce) 이 발생한다.즉, Boolean(a) 와 동일한 결과를 얻게된다. false 가 되는 경우는 undefined이외에도 null, “”, 0 등이 있다.a의 값이 “abc” 또는 1인 경우에는 어떻게 될까? 이때는 빈문자열(“”) 과 0이 아니므로 true 가 되겠다. 12345var a;a = 0;if (a || a === 0) &#123; console.log('hello');&#125; 자 그럼 조금 헷갈리는 코드를 보자. if (a || a === 0)은 어떻게 될까?값을 대입해보면 if (0 || 0 === 0) 이 되는데, hello 가 출력이 될까?operator precedence (연산자 우선순위) 에 따르면, === 이 OR 연산자보다 우선순위가 높다고 나온다.따라서 0 === 0 이므로 true, 다음은 0 || true 즉, false OR true 가 되므로 최종결과 값은 true 가 된다. 자 그럼 이제, Default Values(기본값) 로 넘어가겠다. 12345function greet(name) &#123; console.log('Hello ' + name);&#125;greet(); // output: Hello undefined 결과는 Hello undefined 라고 찍힌다. 예상한 결과인가?필자는 오류가 나거나 Hello 만 찍힐거라고 예상했다.자 그럼, name을 넘기지 않았을 때 기본값을 지정하고 싶다면?아주 간단하게 할 수 있는 방법이 있다. 바로 OR 연산자를 이용하는 것이다. 123true || false; // output: trueundefined || true; // output: true'hello' || 'world' // output: \"hello\" 예상한 결과인가? OR 는 왼쪽과 오른쪽의 값들 중 true인 것을 먼저 반환하는 함수이다. 맞다 연산자는 사실 함수이다.두 값을 파라미터로 받아서 둘 중 true 를 가지고 있는 놈이 있으면 출력해. 둘다 true 이면, 앞에 놈을 먼저 출력하고. 와 같은 내용이 구현되어 있는 것이다. 1234567function greet(name) &#123; name = name || '&lt;Enter your name&gt;'; console.log('Hello ' + name);&#125;greet('World');greet(); 결과는? 그렇다. Hello World 그리고 Hello &lt;Enter your name&gt; 이 된다.저런 코드를 어디선가 만난다면, 반갑게 인사하자. Hello OR!","categories":[{"name":"개발","slug":"개발","permalink":"http://parkseokje.github.io/categories/개발/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://parkseokje.github.io/tags/javascript/"},{"name":"udemy","slug":"udemy","permalink":"http://parkseokje.github.io/tags/udemy/"}]},{"title":"jwt","slug":"jwt","date":"2017-03-07T04:22:40.000Z","updated":"2017-03-08T08:31:49.000Z","comments":true,"path":"2017/03/07/jwt/","link":"","permalink":"http://parkseokje.github.io/2017/03/07/jwt/","excerpt":"","text":"JWT JSON Web Token 의 약자로서, 간단히 말하면, 사용자가 누구이고,무엇을 할 수 있는지에 대한 정보를 담고 있는 객체이다. 서버로부터 클라이언트로 발급되며, 위변조 여부를 알 수 있도록비밀키로 암호화 된다. 로그인과 같은 인증모듈에 사용되며,사용자에 대한 정보를 세션에 저장하지 않는 컨셉이기 때문에클라이언트는 이렇게 받은 토큰을 안전한 장소에 저장해야 한다. 또한 매 서버 요청 시 이 토큰을 헤더나 쿼리 파라미터 등에 포함시켜 보내야 한다. 자 그럼 바로, Node Express 예제를 통해 알아보자. (express 프로젝트 생성) Passport 간단히 말하면, Node.js용 범용 인증 모듈이다.아래 준비물에 나와있는 passport-jwt 는 passport 의 수많은 인증방식(Strategy) 중JWT 를 결합하여 사용할 수 있도록 만들어진 모듈이다. 설치1npm install --save passport, passport-jwt, jwt-simple routes/users.js 사용자 인증을 위한 Fake 데이터 123456789101112131415var users = [&#123; id: 1, name: 'John', email: 'john@mail.com', phone: '01012341234', password: '1111'&#125;, &#123; id: 2, name: 'Sarah', email: 'sarah@mail.com', phone: '01023456789', password: '2222'&#125;];module.exports = users; secret/jwt_config.js 비밀키. 반드시 .gitignore 시키자. 12345678module.exports = &#123; // 토큰을 인코딩/디코딩하기 위한 비밀키로 사용된다. jwtSecret: 'ilovecode', // Passport 세션을 이용하지 않도록 알려주는 역할을 한다. jwtSession: &#123; session: false &#125;&#125;; routes/auth.js 사용자 인증을 처리할 모듈 1234567891011121314151617181920212223242526272829303132333435363738var passport = require('passport');var passportJWT = require('passport-jwt');var users = require('./users');var cfg = require('../secret/jwt_config');var ExtractJwt = passportJWT.ExtractJwt;var Strategy = passportJWT.Strategy;var params = &#123; // JWT 비밀키 secretOrKey: cfg.jwtSecret, // 클라이언트에서 서버로 토큰을 전달하는 방식 (header, querystring, body 등이 있다.) // header 의 경우 다음과 같이 써야 한다 &#123; key: 'Authorization', value: 'JWT' + 토큰 jwtFromRequest: ExtractJwt.fromAuthHeader()&#125;;module.exports = function () &#123; var strategy = new Strategy(params, function (payload, done) &#123; // TODO write authentications to find users from a database var user = users.find(function (u) &#123; return u.id === payload.id; &#125;); if (user) &#123; return done(null, &#123; id: user.id &#125;); &#125; else &#123; return done(new Error('User not found'), null); &#125; &#125;); passport.use(strategy); return &#123; initialize: function () &#123; return passport.initialize(); &#125;, authenticate: function () &#123; return passport.authenticate('jwt', cfg.jwtSession); &#125; &#125;;&#125;; app.js 123456var bodyParser = require('body-parser');var auth = require('./routes/auth')(); // 위의 auth.js 를 추가한다....app.use(express.static(path.join(__dirname, 'public')));app.use(auth.initialize()); // 초기화 routes/index.js 2개의 라우터를 정의한다. /login: 로그인 요청. 토큰을 발급한다. /secret: 토큰을 통해 사용자 정보를 획득한다. 123456789101112131415161718192021222324252627282930313233343536373839var express = require('express');var router = express.Router();var jwt = require('jwt-simple');var auth = require('./auth')();var users = require('./users');var cfg = require('../secret/jwt_config');// 로그인 요청을 처리한다.// 1. body 에 포함된 전화번호와 암호가 일치하는 사용자를 찾는다.// 2. 토큰(payload + 비밀키) 생성 및 전송router.post('/login', function (req, res) &#123; if (req.body.phone &amp;&amp; req.body.password) &#123; var phone = req.body.phone; var password = req.body.password; var user = users.find(function (u) &#123; return u.phone === phone &amp;&amp; u.password === password; &#125;); if (user) &#123; var payload = &#123; id: user.id &#125;; var token = jwt.encode(payload, cfg.jwtSecret); res.json(&#123; token: token &#125;); &#125; else &#123; res.sendStatus(401); &#125; &#125; else &#123; res.sendStatus(401); &#125;&#125;);// 클라이언트로부터 전송된 요청 헤더에 포함된 토큰으로부터 사용자 정보를 반환한다.router.get('/secret', auth.authenticate(), function (req, res) &#123; res.send(req.user);&#125;);module.exports = router; 테스트 start``` 또는 [nodemon 으로 서버를 실행]하고 Postman 등으로 테스트해보자1234567```[POST, 토큰 획득]http://localhost:3000/login, [BODY] phone: 01012341234, password: 1111(Postman 으로 할 경우 x-www-form-urlencoded 옵션 선택)[GET, 위 토큰을 통해 사용자 정보 획득]http://localhost:3000/secret, [HEADER] key: Authorization, value: 토큰 참고 Implementing JWT using Passport Express, Passport and JSON Web Token (jwt) Authentication for Beginners passport passport-jwt jwt Understanding passport.js authentication flow Create and Verify JWTs with Node.js ExpressJS 에서 로그인/로그아웃 구현하기 JWT(JSON Web Token)을 이용한 API 인증 - #1 개념 소개 REST JWT(JSON Web Token)소개 - #2 node.js에서 JWT 사용하기 JWT에 대하여","categories":[{"name":"개발","slug":"개발","permalink":"http://parkseokje.github.io/categories/개발/"}],"tags":[{"name":"api","slug":"api","permalink":"http://parkseokje.github.io/tags/api/"},{"name":"passport","slug":"passport","permalink":"http://parkseokje.github.io/tags/passport/"},{"name":"jwt","slug":"jwt","permalink":"http://parkseokje.github.io/tags/jwt/"},{"name":"nodejs","slug":"nodejs","permalink":"http://parkseokje.github.io/tags/nodejs/"},{"name":"expressjs","slug":"expressjs","permalink":"http://parkseokje.github.io/tags/expressjs/"}]},{"title":"apidoc","slug":"apidoc","date":"2017-03-07T04:22:10.000Z","updated":"2017-03-08T08:31:34.000Z","comments":true,"path":"2017/03/07/apidoc/","link":"","permalink":"http://parkseokje.github.io/2017/03/07/apidoc/","excerpt":"","text":"swagger 로 api 문서화를 해보려 하였으나, 아래 부분에서 막혔다. 기존 nodejs + express 방식에 적용하고자 할 경우 yaml 파일을 route 또는 특정 그룹별로 분리하고자 할 경우 yaml 파일에 api spec 작성도 해야하고, api 개발은 또 별도로 해야하고.. 기능이 방대한 만큼 배워야할 게 많고 Best practice 를 찾기가 어렵다. 욕심이 가는 모듈이지만, 일단 접기로 했다. 그래서 하고 숨겨놨던 [apidoc](http://apidocjs.com/) 을 다시 꺼내어보았다.1234**설치**```javascriptnpm install apidoc -g package.json 수정12345\"apidoc\": &#123; \"title\": \"API 제목\", \"description\": \"API 설명\", \"url\": \"https://my_api_domain/api/v1\"&#125;, comment 작성123456789101112131415161718192021222324252627282930(예시)/** * @api &#123;get&#125; /user/:id Get User information * @apiVersion 0.1.0 * @apiName GetUser * @apiGroup User * * @apiParam &#123;Number&#125; id Users unique ID. * * @apiSuccess &#123;String&#125; firstname Firstname of the User. * @apiSuccess &#123;String&#125; lastname Lastname of the User. * * @apiSuccessExample Success-Response: * HTTP/1.1 200 OK * &#123; * \"firstname\": \"John\", * \"lastname\": \"Doe\" * &#125; * * @apiError UserNotFound The id of the User was not found. * * @apiErrorExample Error-Response: * HTTP/1.1 404 Not Found * &#123; * \"error\": \"UserNotFound\" * &#125; */router.get('/', function(req, res, next) &#123; res.render('index', &#123; title: 'Hello World' &#125;);&#125;); package.json123456(예시) \"scripts\": &#123; \"start\": \"node ./bin/www\", \"dev\": \"nodemon ./bin/www\", \"apidoc\": \"apidoc -i ./routes -o ./public/apidoc\" &#125;, API 문서생성 1 (package.json 이용)1npm run apidoc API 문서생성 2(apidoc CLI 이용)1apidoc -i [target folder, ex: ./routes] -o [destination folder, ex: ./public/apidoc] 출력결과12output:info: Done. 서버실행 후 확인12npm run devlocalhost:3000/apidoc 잠깐 사용해본 결과, 셋업이 상당히 간단하고, 문서화도 잘되어 있다.swagger 의 tools, authenticate, api test 와 같은 built-in은 없지만, 개발자 간의 의사소통을위해서는 적당한 것 같다.","categories":[{"name":"개발","slug":"개발","permalink":"http://parkseokje.github.io/categories/개발/"}],"tags":[{"name":"api","slug":"api","permalink":"http://parkseokje.github.io/tags/api/"}]},{"title":"swagger","slug":"swagger","date":"2017-03-07T04:21:38.000Z","updated":"2017-03-08T08:31:57.000Z","comments":true,"path":"2017/03/07/swagger/","link":"","permalink":"http://parkseokje.github.io/2017/03/07/swagger/","excerpt":"","text":"예전부터 들어만 보았지 실제로 사용해본적이 없었던 [Swagger] 에 대해 간단한 경험을 공유해보려 한다.우선 해당 사이트의 설명을 보면, 아래와 같다. 12345678Swagger is a powerful open source framework backedby a large ecosystem of toolsthat helps you design, build, document,and consume your RESTful APIs.Swagger (스웨거) 는 수많은 도구로 이루어진 에코시스템이 뒷받침하고 있으며,RESTful API를 디자인하고, 빌드하고, 문서화하며, 소비할 수 있도록도와주는 강력한 오프소스 프레임웍이다. 음.. 에코시스템은 뭐고,API 는 알겠는데, RESTful 은 뭘까? 에코시스템의 사전적 의미는 여기에서 확인할 수 있다.여기서의 에코시스템은 Swagger 에는 다양한 라이브러리와 프레임웍으로구성된 툴들이 존재하는데, 이들을 묶어서 부르는 것으로 풀이하면 무방할 것 같다.RESTful에 대한 자세한 설명은 이곳을 참고해주기 바란다. 그래서 Swagger 를 이용해서 무엇을 어떻게 하는건가?간단히 말해서, node express 기반으로 만들어진 swagger-express를 이용해 API를 개발한 다음(기존 express 개발 방식과는 완전히 상이하다.), swagger-express 서버를 실행시키면,API 서비스를 제공할 수 있게되며, 별도로 작성한 Swagger 에디터를 이용해 작성한, API 문서를 포함시키면,API 문서도 서비스로 제공할 수 있다는 것이다. 그럼 바로 시작해보자. 아래 내용은 기본적인 준비사항이다. 1234567891011121314151617181920211. swagger-node 글로벌 설치npm install -g swagger2. 프로젝트 생성swagger project create [project_name]cd [project_name](선택사항)git initgit remote add [remote_url])git pull origin [remote_branch] --allow-unrelated-histories(git repo 생성 시 .gitignore/readme 파일을 추가한 경우)3.API 디자인swagger project edit 또는IDE에서 api/swagger/swagger.yaml 파일을 직접 수정4. 프로젝트 시작swagger project startcurl http://127.0.0.1:10010/hello?name=Scott(&quot;Hello, Scott!&quot; 가 찍히면, 성공) 그다음 API 문서를 웹페이지로 제공해주는 swagger ui를 설정해보자. app.js 에 추가1234567891011var SwaggerUi = require('swagger-tools/middleware/swagger-ui');SwaggerExpress.create(config, function(err, swaggerExpress) &#123; // add swagger-ui (/docs) app.use(SwaggerUi(swaggerExpress.runner.swagger)); // install middleware swaggerExpress.register(app);&#125;); 를 실행해보자.1234567891011121314151617181920다음 사항으로는, API 접근을 위한 보안설정을 해보자.**app.js** 에 추가```javascriptvar config = &#123; appRoot: __dirname, // required config swaggerSecurityHandlers: &#123; api_key: function (req, authOrSecDef, scopesOrApiKey, cb) &#123; // your security code // 요청 헤더값이 api_key 이고 값이 1234 일 경우에만 실행을 허용한다 if (&apos;1234&apos; === scopesOrApiKey) &#123; cb(); &#125; else &#123; cb(new Error(&apos;access denied!&apos;)); &#125; &#125; &#125;&#125;; api/swagger/swagger.yaml 에 추가1234567891011121314151617181920212223# api securitysecurityDefinitions: # 오픈 api일 경우 UserSecurity: type: basic # POST, DELETE, UPDATE 등에 적용 AdminSecurity: type: apiSecretKey in: header #name 이 변경되면 반드시 app.js 의 api_key 또한 #adminSecretKey 로 변경해야한다! name: adminSecretKey # 사용자 정의 # 이미지와 같은 정적 파일들에 대해 적용 (선택) MediaSecurity: type: apiKey in: query name: mediaSecretKey # 사용자 정의#아래 path 부분에 security 에 대한 설정이 없을 경우 디폴트로 적용security: - UserSecurity: []#path... securityDefinitions 속성명이 변경되는 경우에는,아래 부분도 함께 변경해주어야 한다. app.js 수정1234var config = &#123; appRoot: __dirname, swaggerSecurityHandlers: &#123; AdminSecurity: ... &lt;-- api/swagger/swagger.yaml 에 추가12345678910paths: /hello: # binds a127 app logic to a route x-swagger-router-controller: hello_world get: description: Returns 'Hello' to the caller # GET /hello 요청이 들어왔을 경우에만 적용할 security security: - AdminSecurity: []... 실패 테스트12curl http://127.0.0.1:10010/hello?name=Scott&#123;&quot;message&quot;:&quot;access denied!&quot;,&quot;code&quot;:&quot;server_error&quot;,&quot;statusCode&quot;:403&#125; access denied 되었다는 것을 볼 수 있다. 성공 테스트12curl -X GET --header &apos;adminSecretKey: 1234&apos; http://localhost:10010/hello?name=Scott&quot;Hello, Scott!&quot; 정상적으로 결과가 반한된다. TODO 추후 서버에 올려서 테스트를 진행해볼 것 참고 API Handyman - defining security 김정환님의 블로그","categories":[{"name":"개발","slug":"개발","permalink":"http://parkseokje.github.io/categories/개발/"}],"tags":[{"name":"api","slug":"api","permalink":"http://parkseokje.github.io/tags/api/"}]},{"title":"부동산 공부","slug":"realty","date":"2017-03-07T04:21:01.000Z","updated":"2017-03-08T10:44:04.000Z","comments":true,"path":"2017/03/07/realty/","link":"","permalink":"http://parkseokje.github.io/2017/03/07/realty/","excerpt":"","text":"부동산 경제학 (김정용 저) 청약은 주택 수요가 많은 광역시나 지는 구도심보다는 떠오르는 신도심, 대규모 택지 개발 지구, 그동안 아파트 공급이 뜸해서 신규 주택 수요가 많은 지역부터 노리는 것이 좋다. 발전 가능성이 높은 지역은 10년간 집값이 몇 배로 뛰기 때문에 이왕이면 이런 곳에 집을 마련하는 것이 재테크의 기본 서울이라면 1가구 1주택으로 3년 이상의 보유 기간에 2년 거주를 해야 양도소득세가 비과세되지만 경기도(과천, 5대 신도시 제외)의 경우 3년간 보유만 하면 양도소득세가 면제되므로 투자 이익을 극대화할 수 있는 것 아파트에 투자를 하려고 한다면 지방보다는 수도권에 투자하는 것이 좋다. 왜냐하면 향후 가격 상승면에서 지방보다는 서울, 수도권이 낫기 때문 새 아파트를 매입하고 1년 이내에 비과세 요건을 충족한 기존 주택을 매도하면 양도소득세가 비과세되기 때문","categories":[{"name":"재테크","slug":"재테크","permalink":"http://parkseokje.github.io/categories/재테크/"}],"tags":[{"name":"부동산","slug":"부동산","permalink":"http://parkseokje.github.io/tags/부동산/"},{"name":"재태크","slug":"재태크","permalink":"http://parkseokje.github.io/tags/재태크/"}]},{"title":"Terminal Tips","slug":"terminalTips","date":"2017-03-07T04:08:43.000Z","updated":"2017-03-08T17:12:24.000Z","comments":true,"path":"2017/03/07/terminalTips/","link":"","permalink":"http://parkseokje.github.io/2017/03/07/terminalTips/","excerpt":"","text":"사용중인 포트 확인 및 제거12sudo lsof -i :portsudo kill -9 pid","categories":[{"name":"개발","slug":"개발","permalink":"http://parkseokje.github.io/categories/개발/"}],"tags":[{"name":"iterm","slug":"iterm","permalink":"http://parkseokje.github.io/tags/iterm/"}]},{"title":"runkit","slug":"runkit","date":"2017-03-07T02:38:56.000Z","updated":"2017-03-08T17:12:49.000Z","comments":true,"path":"2017/03/07/runkit/","link":"","permalink":"http://parkseokje.github.io/2017/03/07/runkit/","excerpt":"","text":"medium 에서 node.js 디자인 패턴 관련 글을 읽다가 아무 생각없이클릭해봤는데 뭔가 대단해보이는 서비스를 발견했다. 그 이름은 바로 runkit 저자는 일일이 로컬에 노드 모듈을 설치해서 테스트 해보기 귀찮으면, 이 걸 써보라고 권장하고 있다.샘플로 제공하는 코드를 보면 우주 정거장의 위치를 제공해주는 소스코드도 포함되어 있다.현재시간 기준으로 네팔을 지나가고 있다ㅋ 들어가보니 깃 계정으로 사인업을 거친 후에는 nodebook 이라는 유닛을 생성할 수 있으며,이 안에 여러가지 스크립트를 작성할 수 있다. 사용하고 싶은 노드 모듈은 import 만 하면 된다. 깃과 연동이 되며 노트북 마다 유니크한 키로 새로운 깃 저장소가 생성되는 구조이며, 실행결과를바로 확인해볼 수 있다. 또한 제공되는 endpoint (url) 를 통해, 브라우져나 터미널에서 curl 명령어로 리턴 결과를 확인해 볼 수도 있다. 개발 단계에서 목업 API를 개발하거나 간단한 코드를 빠른 시간 내에 검증해볼 수 있다는장점이 있을 것 같다. 나중에봐야징ㅋ","categories":[{"name":"개발","slug":"개발","permalink":"http://parkseokje.github.io/categories/개발/"}],"tags":[{"name":"tool","slug":"tool","permalink":"http://parkseokje.github.io/tags/tool/"}]},{"title":"codeReview","slug":"codeReview","date":"2017-03-07T02:36:02.000Z","updated":"2017-03-08T08:31:41.000Z","comments":true,"path":"2017/03/07/codeReview/","link":"","permalink":"http://parkseokje.github.io/2017/03/07/codeReview/","excerpt":"","text":"종류 리뷰 시기 효과 변경내용 수행비용 주체 Code Inspection 1차 릴리즈시스템 테스트 매우높음 매우높음 높음 PMO, QA, AA Team Review 매주 높음 보통 보통 PL Walkthrough 비정기적 낮음 보통 낮음 원하는 개발자 Peer Review 필요한 경우 경우에 따라 높음 낮음 보통 시니어 개발자 설명1. Code Inspection 사용시기 : 1차 릴리즈 (비기능, 높은 리스크, 아키텍쳐 결정 등), 시스템테스트 (개발 후반부, 성능 &amp; 안정성, 최종점검 차원), 난이도가 높은 시스템 수행주체 : QA 조직 내 인스펙션팀, SI 나 벤더 컨설팅 이용 단점: 높은 비용 2. Team Review 사용시기 : 각 개발 유닛마다 수행주체 : 발표자 후속작업 : PL은 리뷰내용을 토대로 발표자의 스케쥴 조정, 문서공유 및 테스크 관리, 테스트 및 검증 3. Walkthrough 사용시기 : 아이디어 회의를 해야하는 경우, 장애사례나 버그 수정사례 등의 정보교환이 필요한 경우, 팀원간의 실력 편차가 클 때 수행주체 : 특별히 정해져있지는 않으나 QA나 운영팀이 할 경우 효과적 단점 : 중재자가 없으므로 구성원들의 의욕이 낮을 경우 효과가 저조함. 4. Peer Review 사용시기 : 신입개발자 교육, 지식공유, 품질유지가 필요한 경우 수행주체 : 좀 더 많이 아는 개발자가 단점 : 수행주체에게 많은 부담을 앉겨줄 수 있다. 효과적인 코드 리뷰를 위해 리뷰의 목적은 결함의 발견과 개선 인신공격, 취조하는 분위기는 금물 중재자의 적절한 진행 리뷰에 대한 후속 처리시간과 인적 리소스에 대한 조직적인 배려 이상으로 요약글을 마친다. 회고본인의 경우 팀원들과도 본 내용들을 공유하고 이해하고 토론하는 시간을 가졌다.우선 릴리즈와 관련된 것은 팀리뷰로 주 1회 정도 진행하기로 하였다.작은 유닛들은 온/오프 리뷰 요청을 통해 1일 1-2회로 제한하고, 가급적 하루 중 오전은 중요한 업무를 하고,오후에 별도로 짬을 내어 리뷰를 진행해보기로 하였다.또한 피어리뷰는 필요할 경우, 따로 시간을 정하거나 다 모일 필요없이 관련 당사자들끼리만 진행할 수 있도록 하였다.리뷰 요청이 발생하면, 요청자가 pull request를 날리거나 위키에 기록하고, 리뷰 후에는 진행 및 처리결과를 업데이트하고,리뷰어는 이를 알림을 통해서 받거나 정해신 시간에 확인하여, 코멘트를 달거나 별도 시간을 내서 오프로 얘기하기로 하였다.오프 리뷰요청이 있을 경우 리뷰 전 최소 1시간 전에는 구성원들이 관련 사항을 미리 파악해두도록 하였다.일단 이렇게 정해서 가고 중간 중간 조율해 나가기로 하였다.이 실험의 결과에 대해서는 기회가 된다면, 추후 다시 포스팅하도록 하겠다. 이 밖에도 아래 참고 사이트에 가보시면, 다양한 관점, 방법 등에 대한내용을 찾아보실 수 있으니, 꼭 #나중에봐야징ㅋ 해두시길 참고 조대협의 블로그 - 코드 리뷰 가이드라인 - Part 1(Code review guidelines) 조대협의 블로그 - 언제 어떤 리뷰 기법을 사용할것인가? - Part 2(Code review guidelines) 실리콘밸리 이야기- 코드 리뷰는 어떻게 하나요? 블로터 - 매끄러운 코드리뷰를 돕는 10가지 방법 realm - 코드리뷰, GitHub로 바로 적용하기 신현묵 - 소스코드 리뷰에 대한 짧은 이야기 카카오테크 - 코드리뷰, 어디까지 해봤니?","categories":[{"name":"개발","slug":"개발","permalink":"http://parkseokje.github.io/categories/개발/"}],"tags":[{"name":"codereview","slug":"codereview","permalink":"http://parkseokje.github.io/tags/codereview/"}]},{"title":"connectionPool","slug":"connectionPool","date":"2017-03-07T02:33:36.000Z","updated":"2017-03-08T08:31:44.000Z","comments":true,"path":"2017/03/07/connectionPool/","link":"","permalink":"http://parkseokje.github.io/2017/03/07/connectionPool/","excerpt":"","text":"wikipedia 커넥션 풀은, 일종의 캐시(cache, 고속 기억장치)로서 DB와의 커넥션(연결)을 유지하고 있다가 새로운 요청이 들어올때마다 DB와 새로운 커넥션을 맺는 대신,기존 커넥션을 재사용하여 DB 처리능력을 향상시키는데 사용된다.매 사용자마다 커넥션을 맺는 것은 특히, 동적으로 DB 연결이 자주 발생하는 웹어플리케이션의 경우 많은 리소스가 소모된다.커넥션이 최초 생성되면, 커넥션풀은 이를 저장하고 요청 시 이를 반환하게 된다.모든 커넥션이 사용중이면, 새로운 커넥션이 생성되고 다시 또 커넥션풀에 저장된다.커넥션풀은 사용자 대기시간을 줄여준다. 현재 node 환경에서 mysqljs 를 사용하고 있는데, commons/db_conn.js1234567891011121314151617181920212223242526272829var mysql = require('mysql');var config = require('../secret/db_info').dev; // DB 연결정보module.exports = function () &#123; return &#123; init: function () &#123; return mysql.createConnection(&#123; host: config.host, port: config.port, user: config.user, password: config.password, database: config.database &#125;); &#125;, test_open: function (conn) &#123; conn.connect(function (err) &#123; if (err) &#123; console.error('mysql connection error.'); console.error(err); throw err; &#125; else &#123; console.info('mysql is connected successfully.'); &#125; &#125;); &#125; &#125;;&#125;; 이렇게 선언하고, 실제 사용 시 매 파일마다아래와 같이 새로운 커넥션 인스턴스를 생성하고 있다. routes/something.js12var mysql_dbc = require('../commons/db_conn')();var connection = mysql_dbc.init(); 실제로 MySQLWorkbench 의 Management 탭에서 확인해보면 실제 접속자 수는 1명인데,15개의 connection 이 존재하는 것을 볼 수 있다. 아직 테스트 코드 검증이 끝나지 않은 상태에서 기존 파일을 덮어쓰면 대참사(?)가 벌어질 수 있으므로,db_conn_pool.js 을 새롭게 생성한다. routes/db_conn_pool.js123456789101112131415var mysql = require('mysql');var config = require('../secret/db_info').dev;const pool = mysql.createPool(&#123; host: config.host, port: config.port, user: config.user, password: config.password, database: config.database // pool 에 담을 수 있는 connection 최대수 // connectionLimit: 20, // true : 가용 connection 이 발생할 때까지 대기 // false : 가용 connection 이 없을 경우 에러 // waitForConnections: false&#125;);module.exports = pool; 사용예12345678pool.getConnection(function (err, connection) &#123; if (err) throw err; connection.query(somequery, function(err, data) &#123; connection.release(); if (err) throw err; //release 해도 data 는 사용가능하다. &#125;);&#125;); 기존에 짜놓은 코드들을 일일히 바꾸려면,시간이 꽤나 걸릴 것 같다. 숙제.. pool 에서 커넥션이 발급/회수가 되는지 검증해보자. Workbench management 대시보드의 수치가 pool과는 어떤 연관성이 있는지 파악해보자. Andrew’s Garage 에 숙제 2번에 대한 설명이 아주 상세히 잘되어 있다. 기타 참고 조대협의 블로그 탁구치는 개발자","categories":[{"name":"개발","slug":"개발","permalink":"http://parkseokje.github.io/categories/개발/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://parkseokje.github.io/tags/mysql/"}]}]}